var documenterSearchIndex = {"docs":
[{"location":"#BlackHole-documentation","page":"Home","title":"BlackHole documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BlackHole","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Structures","page":"Home","title":"Structures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [BlackHole]\nOrder = [:type]","category":"page"},{"location":"#BlackHole.EddingtonFinkelstein","page":"Home","title":"BlackHole.EddingtonFinkelstein","text":"Eddington-Finkelstein metric describing a Black Hole in spherically symmetric space.\n\n\n\n\n\n","category":"type"},{"location":"#BlackHole.GaussianThinDisk","page":"Home","title":"BlackHole.GaussianThinDisk","text":"Disk with Gaussian profile for opacity.\n\n\n\n\n\n","category":"type"},{"location":"#BlackHole.GeometricDisk","page":"Home","title":"BlackHole.GeometricDisk","text":"Geometric disk with no opacity. Does not consider relativistic, doppler or any other effects.\n\n\n\n\n\n","category":"type"},{"location":"#BlackHole.Singularity","page":"Home","title":"BlackHole.Singularity","text":"Super type of all space time metrics.\n\n\n\n\n\n","category":"type"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"calcgeodesics\nrenderdisk","category":"page"},{"location":"#BlackHole.calcgeodesics","page":"Home","title":"BlackHole.calcgeodesics","text":"function calcgeodesics(\n    s::Singularity;\n    num::Int=1500,\n    Δϕ::Float64=0.004,\n)::Array{Float64,3}\n\nCalculate integrated geodesic curves for a given singularity.\n\nPerforms num geodesic traces, each differing in initial velocity 4-vector by an angle Δϕ in the x, y plane.\n\nNote, the method for extracting the results from the integration solutions, and the actual method of integration, is quite tentative at the moment, and requires some investigation.\n\nIf num is too low, it can lead to aliasing problems in the final render.\n\nIf Δϕ is too low, the integrator calculates light paths which swing around and terminate in odd locations, leading to \"jets\" streaming out of the black hole into the plane of the disk (where there really should not be any jets).\n\nExtended help\n\nThe root cause of the integration issue lies probably in how the integration chart was adapted with the observer function. A more discriminating observer may improve the renderings significantly.\n\n\n\n\n\n","category":"function"},{"location":"#BlackHole.renderdisk","page":"Home","title":"BlackHole.renderdisk","text":"renderdisk(\n    ::Val{:gpu},\n    disk::AccretionDisk,\n    geodesics::AbstractArray{<:Number},\n    width::Int,\n    height::Int,\n    fov::Int,\n)\n\nDispatch method for rendering the disk using the GPU.\n\nExtended help\n\nThe kernel launch configuration is hard-coded into this function, which launches two kernels: kernel_index_calculator and kernel_geodesic_render. See the documentation of these individual functions for more details.\n\n\n\n\n\nrenderdisk(\n    ::Val{:cpu},\n    disk::AccretionDisk,\n    geodesics::AbstractArray{<:Number},\n    width::Int,\n    height::Int,\n    fov::Int,\n)\n\nDispatch method for rendering the disk using the CPU.\n\n\n\n\n\nrenderdisk(\n    disk::AccretionDisk,\n    geodesics::AbstractArray{<:Number};\n    width::Int = 480,\n    height::Int = 720,\n    fov::Int = 200\n)\n\nRender an accretion disk disk given an array of pre-calculated geodesics geodesics for the disk.\n\nReturns an array of dimensions width by height, representing the rendered image. \n\nThis method checks whether CUDA is installed, and dispatches a GPU kernel accordingly. Otherwise, the rendering functions are executed in parallel on the CPU. \n\n\n\n\n\n","category":"function"},{"location":"internals/#Internal-Methods","page":"Internal Methods","title":"Internal Methods","text":"","category":"section"},{"location":"internals/","page":"Internal Methods","title":"Internal Methods","text":"Documentation for methods not exported by the module, included for development purposes.","category":"page"},{"location":"internals/#Utility-Methods","page":"Internal Methods","title":"Utility Methods","text":"","category":"section"},{"location":"internals/","page":"Internal Methods","title":"Internal Methods","text":"Modules = [BlackHole]\nPages = [\"utils.jl\"]","category":"page"},{"location":"internals/#BlackHole.dspher2xyz-Tuple{Any, Any, Any, Any, Any, Any, BlackHole.AccretionDisk}","page":"Internal Methods","title":"BlackHole.dspher2xyz","text":"dspher2xyz(r, θ, ϕ, dr, dθ, dϕ, disk::AccretionDisk)\n\nTransform differential coordinates from spherical to cartesian, at a given point r, θ, ϕ, also performing relevant transformation for plane of disk.\n\nReturns (dx, dy, dz).\n\nTakes Jacobian into account. Symbolic expressions originally calculated with SageMaths.\n\nComplement to dxyz2spher.\n\n\n\n\n\n","category":"method"},{"location":"internals/#BlackHole.dxyz2spher-NTuple{6, Any}","page":"Internal Methods","title":"BlackHole.dxyz2spher","text":"dxyz2spher(x, y, z, dx, dy, dz)\n\nTransform differential coordinates from cartesian to spherical, at a given point x, y, z.\n\nReturns (dr, dθ, dϕ).\n\nTakes Jacobian into account. Symbolic expressions originally calculated with SageMaths.\n\nComplement to dspher2xyz.\n\n\n\n\n\n","category":"method"},{"location":"internals/#BlackHole.inclination_transform-NTuple{5, Any}","page":"Internal Methods","title":"BlackHole.inclination_transform","text":"inclination_transform(x, y, z, α, β)\n\nTransform a point on x,y,z to the inclination given by a rotation of α around x, and β around z.\n\nReturns (x, y, z) in the rotated plane.\n\n\n\n\n\n","category":"method"},{"location":"internals/#BlackHole.spher2xyz-NTuple{4, Any}","page":"Internal Methods","title":"BlackHole.spher2xyz","text":"spher2xyz(t, r, θ, ϕ)\n\nTransform coordinates of a space time point in spherical to cartesian coordinates.\n\nReturns (t, x, y, z).\n\n\n\n\n\n","category":"method"},{"location":"internals/#BlackHole.truncator-Tuple{Any}","page":"Internal Methods","title":"BlackHole.truncator","text":"truncator(px)::UInt8\n\nClamps value of px between 0 and 255.\n\n\n\n\n\n","category":"method"},{"location":"internals/#Rendering-Kernels","page":"Internal Methods","title":"Rendering Kernels","text":"","category":"section"},{"location":"internals/","page":"Internal Methods","title":"Internal Methods","text":"CurrentModule = BlackHole","category":"page"},{"location":"internals/","page":"Internal Methods","title":"Internal Methods","text":"kernel_geodesic_render\nkernel_index_calculator","category":"page"},{"location":"internals/#BlackHole.kernel_geodesic_render","page":"Internal Methods","title":"BlackHole.kernel_geodesic_render","text":"kernel_geodesic_render(\n    indeximage::AbstractArray{T},\n    β_store::AbstractArray{<:Number},\n    geo_matrix,::AbstractArray{<:Number},\n    width::Int, height::Int,\n    step_num::Int,\n    disk::GeometricDisk,\n    max_index::Int\n) where T <: Int\n\nCUDA kernel for computing the integrated paths of geodesics through an accretion disk. indeximage is the result from calling kernel_index_calculator, and is a matrix containing the geodesic index for each pixel.\n\nmax_index is the maximal index of the geodesics matrix, i.e. size(geo_matrix, 3).\n\nTo be launch with threads = 512 blocks = length(indeximage), until better topology is implemented.\n\nExtended help\n\nThis kernel works by using one compute block per pixel, and calculating the difference between two points in spacetime along the geodesic per thread. The thread then calculates whether the line length between these points intersects the accretion disk, and sets a value in a shared memory buffer: in essense, each thread calculates\n\n    geodesics[:, thread + 1, geoindex] - geodesics[:, thread, geoindex]\n\ntransformed by the angles of the accretion disk. This allows the intersection to be calculated from the z component: 0 leq fracz_iz_i - z_i+1  1\n\nInternally, the offsets are mapped with the column major formula\n\nn x m x p:\n    arr[i, j, k] == arr[(n*m)*(k-1) + n*(j-1) + i]\n\nto avoid getindex function calls.\n\nAt the end of the kernel, a simple reduce algorithm is implemented to sum over the shared array. The first thread of each block then stores the value back into indeximage as the output of the kernel.\n\nBetter topology for this kernel would have the y dimension continue to calculate the same pixel, incase there are more geodesic integration steps (step_num) than threads can be spawned. Due to the size of this kernel, only about 512 threads can be spawned on my hardware before the device runs out of resources.\n\n\n\n\n\n","category":"function"},{"location":"internals/#BlackHole.kernel_index_calculator","page":"Internal Methods","title":"BlackHole.kernel_index_calculator","text":"function kernel_index_calculator(\n    oimg::AbstractArray{Int},\n    β_store::AbstractArray{<:Number},\n    width::Int,\n    height::Int,\n    fov::Int,\n    num_geodesics::Int\n)\n\nCUDA kernel for calculating which index of the geodesic array to use in each pixel. The index calculated for a given y, x position is stored in oimg[y, x]. β_store[y, x] also stores the corresponding pixel's angle around the x axis, used for calculating inclination into the accretion disk in the second kernel (kernel_geodesic_render).\n\nfov is a \"field of view\" index, used to adjust which pixel maps to the end of the geodesic array (num_geodesics). As a rough guideline, fov=1000 maps the pixel at distance r=1000 to the last index of the geodesic array.\n\n\n\n\n\n","category":"function"}]
}
